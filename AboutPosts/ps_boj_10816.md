---
title: "백준 #10816: 숫자 카드 2"
date: "2025-01-31"
category: "CS Field > PS Study > 백준 문제풀이"
---

### 문제 설명
숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 몇 개 가지고 있는지 구하는 프로그램을 작성하시오.
[문제 링크](https://www.acmicpc.net/problem/10816)

---

### 입력
첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.

셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 몇 개 가지고 있는 숫자 카드인지 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다.

---

### 출력
첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 몇 개 가지고 있는지를 공백으로 구분해 출력한다.

---

### C++ 코드
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int n,m;
    cin >> n;
    vector<int> vec(20000000);
    for (int i =0;i<n;i++){
        int k;
        cin >> k;
        vec[k+10000000]++;
    }
    cin >> m;
    int k;
    for (int i =0;i<m;i++){
        cin >> k;
        cout << vec[k+10000000] << ' ';
    }
    return 0;
}
```

---
처음에는 자연스레 set으로 접근할 생각을 했었다. 그래서 multiset 기반으로 구현을 했었다.  
근데 시간 초과가 뜨더라구..  
솔직히 좀 기뻤다 ㅋㅋㅋ PS 하면서 시간초과를 보게 될 정도로 발전했구나.. 싶었다  
암튼, 그래서 set 시간복잡도를 다시 찾아보는데 RRLB 기반 구현이라 O(log N)이라 하더라. log N이 안 되는 수준인거면.. 일단은 (amortized analysis 기반) O(1)이 나오는 unordered set을 이용해서 다시 구현해봤다. 근데 그것도 시간초과야!  
그래서 아 이걸 어쩐다.. 하다가 chatGPT에게 물어봤다. map 기반으로 구현하면 된다고 하길래..  
내가 왜 저 생각을 못 했지 싶으면서 index 기반 빠른 접근이 가능한 vector 구조를 기반으로 -실은 array로 하는 게 조금 더 빠르다 보니.. array로 할까 싶었지만, array는 stack의 메모리 사용/vector는 heap의 메모리 사용에서 자칫 잘못하면 stackoverflow 뜰까봐 vector로 진행했다.- 크기 2천만 짜리 배열 잡아서(ㅋㅋㅋ) 풀었다.  
인상적이었스